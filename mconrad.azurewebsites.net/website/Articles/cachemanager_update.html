<h1 id="update-operations">Update Operations</h1>



<h2 id="why-when-to-use-update">Why / When to use <code>Update</code></h2>

<p>
	Updating a cache item in a distributed cache is different from just changing the item within an in-process cache.  <br>
	With in-process caches, we can ensure thread safe writes, and with poco objects, the in-process cache will just keep the reference to that object and therefor always holds the same version for all threads.
</p>

<p>
	With distributed caches, we cannot assume the same. The cache item will be serialized and send to a server, in case multiple clients update the same item, one of the clients will win, the other one will loose. <br>
	Let’s say you have a click counter stored in a distributed cache and both clients update the number. Before the update the number was 10 and every client increase the number by 1. The result would be 11 because one client would override the update of the other client…
</p>

<p>To prevent such scenarios and ensure you don’t loose any data, every distributed cache provider has some slightly different ways to handle that. </p>



<h2 id="how-to-use-update">How to use <code>Update</code></h2>

<p>Cache Manager provides a simple interface to make this whole process very easy to use, the <code>Update</code> method.</p>

<pre><code>cache.Update("key", counter =&gt; counter + 1);
</code></pre>

<p>The lambda expression provides the old value as input and takes the updated value as output.</p>

<p>Now, if a conflict occurs during the update operation, which can happen if another client updates the same item, Cache Manager will call the lambda again with the new version of the value as input.</p>

<p>Back to our example, Cache Manager would handle that version conflict if you use the <code>Update</code> method and increase the counter by one for the first client. The second client would handle the version conflict and increase the counter by one on the second try and the result would be correct.</p>

<p>Per default, Cache Manager will retry update operations as long as needed to successfully update the cache item. You can also limit the number of retries: </p>

<pre><code>cache.Update(
    "key", 
    obj =&gt; "new value", 
    new UpdateItemConfig(100, VersionConflictHandling.EvictItemFromOtherCaches));
</code></pre>

<p>If Cache Manager reaches the limit, the Update will not be successful and you would have to handle that by reacting on the returned value.</p>

<p>In addition you can configure what Cache Manager should do in case a version conflict occurred during the update operation. This will be executed even if the update was not successful (maybe because of the retry limit)</p>

<p>Per default, Cache Manager will remove the cache item from all other handles, because it assumes the other handles don’t have the same version of the cache item.</p>



<h2 id="update-method-variants">Update method variants</h2>

<p>There are currently three different method which provide the update functionality:</p>

<ul>
	<li>
		<code>Update</code> <br>
		As shown above, the <code>Update</code> method will try to safely update the element with your instruction. <br>
		The method returns the updated value if the update was successful and <code>Null</code> if not.
	</li>
	<li>
		<code>TryUpdate</code> <br>
		Does the same as <code>Update</code> but returns <code>True</code> if the update was successful, <code>False</code> if not, and it has an <code>out</code> parameter with the updated value which will also be <code>Null</code> if the update failed.
	</li>
	<li>
		<code>AddOrUpdate</code> <br>
		This method can be used to ensure the cached item is present before updating it. If the cache item is not already stored in cache, it will be added, otherwise the update function will get executed.
	</li>
</ul>



<h2 id="example-1">Example 1</h2>

<p>Let’s look at a simple example using all the <code>Update</code> methods:</p>

<p>First create a cache</p>

<pre><code>var cache = CacheFactory.Build&lt;string&gt;("myCache", s =&gt; s.WithSystemRuntimeCacheHandle("handle"));
Console.WriteLine("Testing update...");
</code></pre>

<p>Inspect what happens if we try to update an item which has not yet been added to the cache:</p>

<pre><code>string newValue;
if (!cache.TryUpdate("test", v =&gt; "item has not yet been added", out newValue))
{
    Console.WriteLine("Value not added?: {0}", newValue == null);
}
</code></pre>

<p>Now we add it to the cache</p>

<pre><code>cache.Add("test", "start");
Console.WriteLine("Inital value: {0}", cache["test"]);
</code></pre>

<p>Let’s see what <code>AddOrUpdate</code> does, it should run the update in this case:</p>

<pre><code>cache.AddOrUpdate("test", "adding again?", v =&gt; "updating and not adding");
Console.WriteLine("After AddOrUpdate: {0}", cache["test"]);
</code></pre>

<p>Removing the item, will cause the following <code>Update</code> call to return <code>Null</code> again</p>

<pre><code>cache.Remove("test");
var removeValue = cache.Update("test", v =&gt; "updated?");
Console.WriteLine("Value after remove is null?: {0}", removeValue == null);
</code></pre>



<h2 id="example-2">Example 2</h2>

<p>The second example will increase a counter in a loop:</p>

<pre><code>cache.AddOrUpdate("counter", 0, v =&gt; v + 1);
Console.WriteLine("Initial value: {0}", cache.Get("counter"));
for (int i = 0; i &lt; 12345; i++)
{
    cache.Update("counter", v =&gt; v + 1);
}
Console.WriteLine("Final value: {0}", cache.Get("counter"));
</code></pre>

<p>
	<div class="toc">
		<ul>
			<li>
				<a href="#update-operations">Update Operations</a><ul>
					<li><a href="#why-when-to-use-update">Why / When to use Update</a></li>
					<li><a href="#how-to-use-update">How to use Update</a></li>
					<li><a href="#update-method-variants">Update method variants</a></li>
					<li><a href="#example-1">Example 1</a></li>
					<li><a href="#example-2">Example 2</a></li>
				</ul>
			</li>
		</ul>
	</div>
</p>